# 前端工程化的理解

---

## 什么是"前端工程化"？

目前来说，web业务日益复杂化和多元化，前端开发从WebPage模式为主转变为WebApp模式为主了。前端的开发工作在一些场景下被认为只是日常的一项简单工作，或只是某个项目的"附属品"，并没有被当做一个"软件"而认真对待（无论是产品负责人还是开发者）。

在模式的转变下，前端都已经不是过去的拼几个页面和搞几个jq插件就能完成。当工程复杂就会产生许多问题，比如：

* 如何进行高效的多人协作？
* 如何保证项目的可维护性？
* 如何提高项目的开发质量？
* 如何降低项目生产的风险？
* ...

**前端工程化**是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的**为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间**，而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。

"前端工程化"里面的工程指**软件工程**，和我们一般说的**工程**是两个完全不同的概念。

工程是个很泛泛的概念，甚至可以认为建了一个git仓库就相对于新建了一个工程；
软件工程的定义是: "应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科"（GB/T11457-2006《信息技术 软件工程术语》）。

* 工程是个很泛泛的概念，甚至可以认为建了一个git仓库就相对于新建了一个工程；
* 软件工程的定义是: "应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科"（GB/T11457-2006《信息技术 软件工程术语》）。

## 如何做"前端工程化"？

前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从**模块化**、**组件化**、**规范化**、**自动化**四个方面思考。

## 模块化

> 简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。

### JS的模块化

在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。

现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。

1. 用++Webpack + Babel++将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；
2. 用++System+Babel++主要是分模块异步加载；
3. 用浏览器的`<script type="module">`加载。

### css的模块化

虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。

按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。

为了避免全局选择器的冲突，需要制定CSS命名风格：

* BEM风格
* Bootstrap风格
* ...

但是这毕竟是弱约束。所以很赞同一句话：

> 与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。

从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。

* Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；
* CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；
* CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。

### 资源的模块化

Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。

资源模块化后，优点是：

* 依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；
* 资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；
* 项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数： dest = webpack(src, config)。

## 组件化

从UI拆分下来的**每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元**，我们称之为**组件**。

> `组件化≠模块化`。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。

其实，组件化更重要是一种分治思想。

> Keep Simple. Everything can be a component.

页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。

传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。

其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。

所以我们除了封装组件本身，还要合理处理组件之间的关系，比如 （逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。

目前市面上的组件化框架很多，主要的有Vue、React、Angular。Vue文档中的对比其他框架一文已经讲得很详细了。

## 规范化

规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。

比如：

* 目录结构的制定

  目录结构的合理设定，能为项目带来很多优点：
  * 有助于提高项目的逻辑结构合理性；
  * 对应扩展和合作；
  * 方便资源的统一定位管理。

* 编码规范

  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。
  推荐参考凹凸实验室打造的[前端代码规范](https://guide.aotu.io/docs/index.html)。

  编码规范包括

  * **HTML规范。**
    基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。
  * **CSS规范。**
    统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。
  * **JS规范。**
    统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。
  * **图片规范。**
    了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。
  * **命名规范。**
    从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。

* 前后端接口规范

  “基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。

  接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。

  那么，对于这一SPA阶段，前后端分离有几个重要的关注挑战：

  * **职责分离**
    1. 前后端仅仅通过异步接口(AJAX/JSONP)来编程；
    2. 前后端都各自有自己的开发流程，构建工具，测试集合；
    3. 关注点分离，前后端变得相对独立并松耦合。

    后端	            前端
    提供数据	        接收数据，返回数据
    处理业务逻辑	    处理渲染逻辑
  * **规范原则**
    1. 接口返回数据即显示，前端仅做渲染逻辑处理；
    2. 渲染逻辑禁止跨多个接口调用；
    3. 前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；
    4. 请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；
  * **响应格式**
    1. 响应基本格式及处理状态值的规范。
     * 基本响应格式
     * 列表响应格式
    2. 特殊内容
     * 下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示；
     * 关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False
     * 关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；

* 文档规范

* 组件管理

* git分支管理

* commit描述规范

* 视觉图标规范

* ...

## 自动化

前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:

> 任何简单机械的重复劳动都应该让机器去完成。

* 图标合并

* 持续集成

* 自动化构建

* 自动化部署

* 自动化测试